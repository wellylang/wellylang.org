<h1> Operators</h1><hr>

<p>Welly supports all the operators supported by C. Over the years, these have become quite standard: they are shared by C++, Java, Javascript, Python, and so on.</p>

<p>When a user defines a type, Welly allows them to define its methods and the actions of the operators on it.</p>


<h3>Binary Operators</h3>

<p>Binary operators take two operands and combine them to make the result. Most binary operators are infix operators, meaning that they are written in between the two operand expressions. For example the <code>+</code> in <code>2 + 3</code> is an infix operator that adds <code>2</code> and <code>3</code> to make <code>5</code>. The complete list of infix operators is as follows:</p>

<table class="padded">
  <thead>
    <tr>
      <th width="200">Symbol</th>
      <th>Meaning</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td><code>+</code></td>
      <td>Add or concatenate.</td>
      
    </tr>

    <tr>
      <td><code>-</code></td>
      <td>Subtract.</td>
    </tr>
    <tr>
        <td><code>*</code></td>
        <td>Multiply.</td>
    </tr>
    <tr>
        <td><code>/</code></td>
        <td>Divide. <strong>[1]</strong> </td>
      
    </tr>
    <tr>
        <td><code>%</code></td> 
        <td>Remainder.</td>
    </tr>
    <tr>
        <td><code>**</code></td> 
        <td>Raise left operand to the power of right operand.</td>
    </tr>
    <tr>
        <td><code>&lt;&lt;</code></td> 
        <td>Shift bits left, filling the vacated bits with zeros.</td>
    </tr>
    <tr>
       <td><code>&gt;&gt;</code></td> 
       <td>Shift bits right, preserving the sign.</td>
    </tr>
    <tr>
    <td><code>&gt;&gt;&gt;</code></td> 
    <td>Shift bits right, filling the vacated bits with zeros.</td>
    </tr>
    <tr>
    <td><code>&amp;</code></td> 
    <td>Bitwise AND.</td>
    </tr>
    <tr>
        <td><code>|</code></td>
         <td>Bitwise OR.</td>
    </tr>
    <tr>
        <td><code>^</code></td> 
        <td>Bitwise XOR.</td>
    </tr>
    <tr>
        <td><code>&amp;&amp;</code></td>
         <td>AND, but right operand is only evaluated if necessary.</td>
         </tr>
        <tr><td><code>||</code></td> 
        <td>OR, but right operand is only evaluated if necessary.</td>
    </tr>
    <tr>
        <td><code>&lt;</code></td> 
        <td>Test if less than.</td>
    </tr>
    <tr>
        <td><code>&gt;</code></td> 
        <td>Test if greater than.</td>
    </tr>
    <tr>
        <td><code>&lt;=</code></td> 
        <td>Test if less than or equal.</td>
    </tr>
    <tr>
        <td><code>&gt;=</code></td>
         <td>Test if greater than or equal.</td>
    </tr>
    <tr>
        <td><code>==</code></td> 
        <td>Test if equal.</td>
    </tr>
    <tr>
        <td><code>!=</code></td>
        <td>Test if unequal.</td>
     </tr>
    <tr>
        <td><code>&lt;&gt;</code></td> 
        <td>Test if less than or greater than. <strong>[2]</strong></td>
    </tr>
    <tr>
        <td><code>in</code></td> 
        <td>Test if contains.</td>
    </tr>
    <tr>
        <td><code>:</code></td> 
        <td>Cast to type.</td>
    </tr>
    
  </tbody>
</table>

<div class="callout">
  <p> <strong>[1]</strong> For integers, division rounds the result towards minus infinity.</p>
  <p> <strong>[2]</strong> For integers,<code>&lt;&gt;</code> does the same thing as <code>!=</code>.</p>
</div>


<h3>Unary operators</h3>

<p>
Unary operators take one operand and compute the result from it. Most unary operators are prefix operators, meaning that they are written before the operand expression. For example, the <code>-</code> in <code>-5</code> is a prefix operator that negates <code>5</code> to make <code>-5</code>. The complete list of prefix operators is as follows:</p>

<table class="padded">
<tr><th scope="col">Symbol</th> <th scope="col">Meaning</th></tr>
<tr><td><code>+</code></td> <td>Copy.</td></tr>
<tr><td><code>-</code></td> <td>Negate.</td></tr>
<tr><td><code>~</code></td> <td>Bitwise NOT.</td></tr>
<tr><td><code>!</code></td> <td>Convert to boolean, then NOT.</td></tr>
<tr><td><code>!!</code></td> <td>Convert to boolean.</td></tr>
<tr><td><code>*</code></td> <td>Dreference. <strong>[1]</strong></td></tr>
<tr><td><code>&amp;</code></td> <td>Address of. <strong>[1]</strong></td></tr>
<tr><td><code>new</code></td> <td>Address of a "var" copy.</td></tr>
<tr><td><code>typeof</code></td> <td>Type of. <strong>[2]</strong></td></tr>
<tr><td><code>array const</code></td> <td>Immutable array of. <strong>[3]</strong></td></tr>
<tr><td><code>array var</code></td> <td>Mutable array of. <strong>[3]</strong></td></tr>
<tr><td><code>array</code></td> <td>Any array of. <strong>[3]</strong></td></tr>
<tr><td><code>ref const</code></td> <td>Immutable reference to. <strong>[3]</strong></td></tr>
<tr><td><code>ref var</code></td> <td>Mutable reference to.<strong> [3]</strong></td></tr>
<tr><td><code>ref</code></td> <td>Any reference to. <strong>[3]</strong></td></tr>
<tr><td><code>defer</code></td> <td>Immutable uninitialised instance of. <strong>[3][4]</strong></td></tr>
</table>

<div class="callout">
  <p><strong>[1]</strong> See [the section on references].</p>
  <p><strong>[2]</strong> Types in Welly are themselves values of type <code>type</code>.</p>
  <p><strong>[3]</strong> These operators can only be applied to types.</p>
  <p><strong>[4]</strong> See [the section on cyclic values].</p>
</div>


<h3>Ternary operator</h3>

<p>The ternary operator is written <code>x ? y : z</code>. It evaluates <code>x</code> first, and converts is to a <code>boolean</code>. If the result is <code>true</code>, it computes the result by evaluating <code>y</code>, otherwise by evaluating <code>z</code>. The other operand <code>z</code> or <code>y</code> is not evaluated.</p>

<pre class="prettyprint">
<code>&gt;&gt;&gt;&gt; 4&lt;7 ? "Less" : "Greater"</code>
<samp class="nocode">"Less": str</samp>
</pre>


<h3>Variadic operators</h3>
<p>The "tuple" and "call" operators are variadic, meaning that the number of operands they take can vary.</p>

<p>
The tuple operator takes zero or more operands and groups them into a tuple. For example <code>(x, y)</code> constructs the pair whose first element is <code>x</code>  and whose second element is <code>y</code>. The notation is as follows:</p>

<table class="padded">
<tr><td><code>()</code></td> <td>Constructs the empty tuple.</td></tr>
<tr><td><code>(x,)</code></td> <td>Constructs a 1-tuple containing <code>x</code>.</td></tr>
<tr><td><code>(x, y)</code> or <code>(x, y,)</code></td> <td>Constructs the pair containing <code>x</code> and <code>y</code>.</td></tr>
<tr><td><code>(x, y, z)</code> or <code>(x, y, z,)</code></td> <td>Constructs a triplet.</td></tr>
<tr><td colspan="2">Etc.</td></tr>
</table>

<p>
Note that the syntax  <code>"(x)"</code> does not construct a 1-tuple, but instead means the same as <code>"x"</code>. Round brackets can therefore be used to group expressions, for example if the default precedence and associativity rules don't do what you want <span style="color:red">(see the section on precedence and associativity)</span>.</p>

<p>
The function call operator takes a function operand and zero or more argument operands. It calls the function, passing the operands. The result is the value returned by the function. The notation is as follows:</p>
<table class="padded">
<tr><td><code>f()</code></td><td>Calls "f" passing no arguments.</td></tr></td></tr>
<tr><td><code>f(x) or f(x,)</code></td> <td>Calls "f" passing "x".</td></tr>
<tr><td><code>f(x, y) or f(x, y,)</code></td> <td>Calls "f" passing "x" and "y".</td></tr>
<tr><td><code>f(x, y, z) or f(x, y, z,)</code></td> <td>Calls "f" passing "x", "y" and "z".</td></tr>
<tr><td colspan="2">  Etc.</td></tr>
</table>
   


<h3>Precedence and associativity</h3>


<p>Expressions that use more than one operator can sometimes be ambiguous. The ambiguity is resolved in Welly using precedence and associativity rules, exactly as in other languages. The complete list of precedence rules is as follows:</p>


<table class="padded">
    <tr>
         <td><code>-x.y</code></td>
         <td>means</td>
         <td><code>-(x.y)</code></td>
         <td>not</td>
         <td><code>(-x).y</code></td>
    </tr>
    <tr> 
        <td><code>-x[y]</code></td>
        <td>means</td>
        <td><code>-(x[y])</code></td>
        <td>not</td>
        <td><code>(-x)[y]</code></td>
    </tr>
    <tr>
        <td><code>-x(y)</code></td> 
        <td>means</td>
        <td><code>-(x(y))</code></td>
        <td>not</td>    
        <td><code>(-x)(y)</code> </td>
    </tr>
    <tr>
        <td><code>-x ** y</code></td> 
        <td>means</td>
        <td><code>(-x) ** y</code></td>
        <td>not</td>
        <td><code>-(x ** y)</code></td>
    </tr>
    <tr>
        <td><code>x * y ** z</code></td> 
        <td>means</td>
        <td><code>x * (y ** z)</code></td>
        <td>not</td>     
        <td><code>(x * y) ** z</code></td>
    </tr>
    <tr>
        <td><code>x + y * z</code></td>
        <td>means</td>
        <td><code>x + (y * z)</code></td>
        <td>not </td>  
        <td><code> (x + y) * z</code></td>
    </tr>
    <tr>
        <td><code>x &lt;&lt; y + z</code></td> 
        <td>means</td>
        <td><code>x &lt;&lt; (y + z)</code></td>
        <td>not </td>    
        <td><code>(x &lt;&lt; y) + z</code> </td>
    </tr>
    <tr>
        <td><code>x &lt; y &lt;&lt; z</code></td> 
        <td>means</td>
        <td><code>x &lt; (y &lt;&lt; z)</code></td>
        <td>not</td>     
        <td><code>(x &lt; y) &lt;&lt; z</code></td>
    </tr>
    <tr>
        <td><code>x == y &lt; z</code></td>
         <td>means</td>
         <td><code>x == (y &lt; z)</code></td>
         <td>not</td>     
         <td><code>(x == y) &lt; z</code></td>
         </tr>
    <tr>
        <td><code>x &amp; y == z</code></td>
         <td>means</td>
         <td><code>x &amp; (y == z)</code></td>
         <td>not</td>    
         <td><code> (x &amp; y) == z</code></td>
    </tr>
    <tr>
        <td><code>x ^ y &amp; z</code></td>
         <td>means</td>
         <td><code>x ^ (y &amp; z)</code></td>
         <td>not </td>    
         <td><code>(x ^ y) &amp; z</code></td>
         </tr>
    <tr>
        <td><code>x | y ^ z</code></td> 
        <td>means</td>
        <td><code>x | (y ^ z)</code></td>
        <td>not</td>    
        <td><code>(x | y) ^ z</code></td>
    </tr>
    <tr>
        <td><code>x &amp;&amp; y | z</code></td> 
        <td>means</td>
        <td><code>x &amp;&amp; (y | z)</code></td>
        <td>not</td>     
        <td><code>(x &amp;&amp; y) | z</code></td>
    </tr>
    <tr>
        <td><code>x || y &amp;&amp; z</code></td> 
        <td>means</td>
        <td><code>x || (y &amp;&amp; z)</code></td>
        <td>not</td>    
        <td><code>(x || y) &amp;&amp; z</code></td>
    </tr>
    <tr>
        <td><code>x : y || z</code></td> 
        <td>means</td>
        <td><code>x : (y || z)</code></td>
        <td>not</td>     
        <td><code>(x : y) || z</code></td>
    </tr>
    <tr>
        <td><code>w ? x : y || z</code></td> 
        <td>means</td>
        <td><code>w ? x : (y || z)</code></td>
        <td>not </td>    
        <td><code>(w ? x : y) || z</code></td>
    </tr>
</table>

<p>All postfix operators have the same precedence, which is the same as subscript and call, and higher than prefix operators. All prefix operators have the same precedence, which is higher than all remaining operators. <code>"/"</code> and <code>"%"</code>  have the same precedence as <code>"*"</code>. Binary <code>"-"</code> has the same precedence as binary <code>"+"</code>. The three shift operators have the same precedence. The five comparison operators have the same precedence. <code>"=="</code> and <code>"!="</code>  have the same precedence.</p>

<h5>The complete list of associativity rules is as follows:</h5>

<table class="padded">
    <tr>
        <td><code>x ** y ** z</code></td>
        <td>means</td>
        <td><code>x ** (y ** z)</code></td>
        <td>not</td>
        <td><code>(x ** y) ** z</code></td>
    </tr>
    <tr>
        <td><code>x * y / z</code></td> 
        <td>means</td>
        <td><code>(x * y) / z</code></td>
        <td>not</td>    
        <td><code>x * (y / z)</code></td>
    </tr>
    <tr> 
        <td><code>x + y - z</code></td> 
        <td>means</td>
        <td><code>(x + y) - z</code></td>
        <td>not</td>     
        <td><code>x + (y - z)</code></td>
    </tr>
    <tr>
        <td><code>x &lt;&lt; y &gt;&gt; z</code></td> 
        <td>means</td>
        <td><code>x &lt;&lt; (y &gt;&gt; z)</code></td>
        <td>not </td>    
        <td><code>(x &lt;&lt; y) &gt;&gt; z</code></td>
    </tr>
    <tr>
        <td><code>x &lt; y &gt; z</code></td> 
        <td>means</td>
        <td><code>(x &lt; y) &gt; z</code></td>
        <td>not</td>     
        <td><code>x &lt; (y &gt; z)</code></td>
    </tr>
    <tr>
        <td><code>x == y != z</code></td> 
        <td>means</td>
        <td><code>(x == y) != z</code></td>
        <td>not</td>   
        <td><code> x == (y != z)</code></td>
    </tr>
    <tr>
        <td><code>x &amp; y &amp; z</code></td> 
        <td>means</td>
        <td><code>(x &amp; y) &amp; z</code></td>
        <td>not</td>     
        <td><code>x &amp; (y &amp; z)</code></td>
    </tr>
    <tr>
        <td><code>x ^ y ^ z</code></td>
         <td>means</td>
         <td><code>(x ^ y) ^ z</code></td>
         <td>not</td>   
         <td><code> x ^ (y ^ z)</code></td>
    </tr>
    <tr>
        <td><code>x | y | z</code></td>
         <td>means</td>
         <td><code>(x | y) | z</code></td>
         <td>not</td> 
         <td><code>x | (y | z)</code></td>
    </tr>
    <tr>
        <td><code>x &amp;&amp; y &amp;&amp; z</code></td> 
        <td>means</td>
        <td><code>(x &amp;&amp; y) &amp;&amp; z</code></td>
        <td>not</td>    
        <td><code>x &amp;&amp; (y &amp;&amp; z)</code></td>
    </tr>
    <tr>
        <td><code>x || y || z</code></td> 
        <td>means</td>
        <td><code>(x || y) || z</code></td>
        <td>not</td>     
        <td><code>x || (y || z)</code></td>
    </tr>
</table>

<h5>Combinations of the cast and ternary operators are deemed so confusing that they are forbidden:</h5>

<table class="padded">
    <tr>
        <td><code>x : y : z</code></td>
        <td>is forbidden.</td>
    </tr>
    <tr>
        <td><code>w ? x : y : z </code></td>
        <td>is forbidden.</td>
    </tr>
    <tr>
        <td><code>w : x ? y : z</code></td>
        <td>is forbidden.</td>
    </tr>
    <tr>
        <td><code> v ? w : x ? y : z </code></td>
        <td>is forbidden.</td>
    </tr>
    <tr>
        <td><code>v ? w ? x : y : z</code> </td>
        <td>is forbidden.</td>
    </tr>
</table>

<p>If these rules do not do what you want, or if you want to make your code clearer, you can enclose expressions in round brackets to make the meaning explicit.</p>